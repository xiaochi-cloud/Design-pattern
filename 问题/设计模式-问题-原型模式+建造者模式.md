https://gper.club/homework/subjects/7e7e7f7ff4g5dgc7g64gfe

## 原型模式

> 通过实现`Cloneable`接口怎么实现克隆原理是什么？有什么问题？代码中是如何验证是深克隆还是浅克隆的？

一般都是直接基于内存二进制流来进行拷贝，不会经过构造函数，性能能够提升很多。

- 注意
  - 是浅拷贝的
    - 引用数据类型是不会被拷贝的，拷贝的是内存地址，不会创建一个新的
    - final修饰的变量是不会被拷贝的
- 验证方式
  - 通过比较内存地址来判断

> 深克隆有哪些解决办法？

- 通过序列化和反序列化
- 通过Json工具

> 如果我需要单例，怎么防止克隆破坏单例

- 重写readResolve方法

  

## 建造者模式

> 什么情况下应该考虑到使用建造模式？

- 相同的方法，不同的执行顺序会产生不同的结果的时候需要用到
- 产品类非常复杂，或者产品类的调用顺序不同产生了不同的效能
- 对象构建的过程会用到一些其他对象，对象在创建的过程中不容易得到
- 例如BeanDefinitionBuilder